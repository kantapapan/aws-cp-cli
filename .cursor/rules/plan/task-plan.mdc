---
description: 
globs: 
alwaysApply: true
---
**整理する方法を考慮中**

ユーザーが「導入のための考え方を整理してください」と依頼しています。つまり、開発プロセスにおける「スクラッチパッド」と「メモリシステム」の導入についての考え方を整理したいと思います。それぞれのメリットや構成要素を理解し、効果的に導入できる方法を提案する必要があります。ユーザーが好む形式で、具体的にマークダウン形式で整理し、関連するリソースを加えることを検討しています。


**導入のための整理**

ユーザーが「導入のための考え方を整理してください」と依頼しています。スクラッチパッドとメモリシステム、ルール管理の導入についてです。開発プロセスに役立つ構造的なアプローチを提案する必要があります。具体的には、スクラッチパッドとメモリシステムを利用してタスクを計画し、実行後に反省・更新する流れを説明します。マークダウン形式で整理し、参考記事なども引用します。


**導入計画の整理**

ユーザーの開発環境に合わせて、スクラッチパッドやメモリシステム、管理ルール、プロジェクトルールについて説明します。まずは「なぜメモリが重要か」「主要コンポーネント」「ステップバイステップの導入計画」「ワークフローへの統合」「ベストプラクティス」「注意点」「拡張方法」などのセクションを作成します。各セクションには関連する記事やフォーラム資料を引用し、定義や役割に関する情報を取り込んで参考にします。


**導入計画と注意点**

まず、Cursorには現在メモリが組み込まれておらず、ファイルベースで管理しています。導入ステップは次の通りです：

1. 制限を理解（コンテキストウィンドウ問題）。
2. ファイル構造：.cursor/rules、root scratchpad.md & memories.md。
3. 管理ルール設定（scratchpad-management.mdc、memories-management.mdc）。
4. ワークフロー：計画→実行→反映、タスク反映後にはメモリ更新。
5. クエリ統合：高確信で参照管理。
6. 維持：定期的なリセットとメモリ整頓。
7. カスタマイズ提案：段階的なアプローチとファイルサイズ制限の考慮。


**構造的マークダウンで整理**

ユーザーが日本語でリクエストしているため、最終的な回答は日本語の構造化されたマークダウンにします。具体的なセクションを作成しました: 背景・課題、コンセプト概要、導入ステップ、運用上のベストプラクティス、留意点、まとめ & 次のアクション。必要な場合、記事からファイル構造や役割に関する情報を引用します。また、L3-L5行に関する内容やL11行に関するプレミアムの注意点を参照します。


思考時間: 49 秒


以下では 「Scratchpad + Memories」方式をチームに取り込む際の“考え方”を、段階別に整理しました。Cursor でコードベースが大きくなり、AI が前回までの文脈を忘れやすくなったと感じたときの導入ガイドとしてお使いください。

---

## 1. 背景 ― なぜ“長期記憶”を自前で持たせるのか？

| 制約                              | 影響                                    |
| ------------------------------- | ------------------------------------- |
| **コンテキスト長**…Composer/Chat の入力上限 | 過去の設計方針や API 契約を都度説明するコスト増            |
| **セッションの断絶**…ウィンドウを閉じる・モデル更新    | 実装方針の抜け漏れ・重複実装                        |
| **プロジェクトドキュメントの不足**             | 大規模 PJ では「ドキュメントが追いつくまで AI の精度が上がらない」 |

Scratchpad と Memories を用意し、**「計画 → 実行 → 振り返り → 学習」** のループを AI と共有メモ上で回すことで、上記ギャップを埋めるのが本記事の狙いです。

---

## 2. コンセプト概要

| ファイル                    | 役割                                                              | 典型的な操作                                        |
| ----------------------- | --------------------------------------------------------------- | --------------------------------------------- |
| `scratchpad.md`（タスク計画書） | その場で立てた **暫定タスク計画** を AI が書き込み、人間がレビュー後に確定 ([Zenn][1])          | `@scratchpad-management.mdc` を呼び出し「計画をまとめて」   |
| `memories.md`（振り返りメモ）   | セッション終了時に **学び・注意点** を追記し、次回計画時に再利用 ([Zenn][1])                 | `@memories-management.mdc` 経由で「保存すべき知識を提案→追記」 |
| `.cursor/rules/*.mdc`   | 2 つの管理ルール（scratchpad／memories）を定義し、**更新方法の一貫性** を保つ ([Zenn][1]) |                                               |

> Cursor 公式機能としてはまだ永続メモリが実装されていないため、\*\*Markdown ファイルと .mdc ルールで擬似的な“脳”\*\*を作るイメージです。

---

## 3. 導入ステップ

### 3‑1. 雛形を配置

```
.
├── .cursor
│   ├── rules
│   │   ├── scratchpad-management.mdc
│   │   └── memories-management.mdc
│   ├── scratchpad.md
│   └── memories.md
```

上記 4 ファイルをレポジトリ直下に置く（記事の gist そのまま流用可） ([Zenn][1])

### 3‑2. タスク計画フェーズ

1. Composer を **agent モード**で開く。
2. プロンプト例：

   ```
   @scratchpad-management.mdc に従い、以下のタスクをスクラッチパッドにまとめて。
   過去知識として @memories.md も参照して。
   ```
3. AI が `scratchpad.md` に計画を書き込む → 人がレビュー → 「確定したら実装へ」。

### 3‑3. 実装フェーズ

* 計画外の修正を極力手動で行わず、**Composer に追加指示**して計画との差分を吸収させる。

### 3‑4. 振り返りフェーズ

1. タスク完了後、同じセッションで次を実行：

   ```
   今回得た知見を @memories-management.mdc に従って整理し、
   @memories.md に追記候補を出してください。
   ```
2. AI の提案を **Accept／修正** → `memories.md` に反映。
3. 次回以降、`@memories.md` を参照しながら計画を立てることで **学習が循環**。

---

## 4. 運用ベストプラクティス

| テーマ                  | 推奨                                                                                             |
| -------------------- | ---------------------------------------------------------------------------------------------- |
| **Scratchpad の扱い**   | タスク終了ごとに **リセット**。履歴は memories に集約する                                                           |
| **Memories のフォーマット** | 1 行完結＋タイムスタンプ＋タグ（例 `#feature` `#bug`）で検索性を確保                                                   |
| **オーバーフロー対策**        | 1000 行超えたら `memories2.md` を作成し相互参照 （管理ルール例より）                                                  |
| **コスト管理**            | Composer を多用するため Premium Request 消費が増える点に注意 ([Zenn][1])                                        |
| **モデル安定化**           | `.cursor/rules/*.mdc` を常にタブで開き、**「自動でルールを読ませる」** ことでハルシネーション軽減 ([Cursor - Community Forum][2]) |

---

## 5. 採用判断のチェックリスト

* [ ] **コンテキスト不足を感じる頻度**が増えている
* [ ] プロジェクト規模が **複数万行／複数サービス** になっている
* [ ] ドキュメントの整備より **AI への適応速度** を優先したい
* [ ] Premium Request 増加を **許容できる** （または課金プランを調整済み）
* [ ] チーム全員が **Markdown 運用ルールに従う** 文化がある

---

## 6. まとめ ＆ 次のアクション

1. **雛形 4 ファイル** をリポジトリに追加し、Composer で読み込める状態にする。
2. 小さなタスク（バグ修正など）で **計画→実装→振り返り** を 3 セットほど回し、ワークフローを身体で覚える。
3. Memories が溜まって来たら **タグ付けや分割ルール** を見直し、検索性を確保。
4. Premium Request の消費量をモニターし、**運用コストと効果**をバランス評価。

このループを 10 セッションほど続けると、Cursor が「自プロジェクト専用の熟練ペアプログラマー」のように振る舞ってくる感覚が得られます。まずは小規模スコープで試行し、手応えを見てから全体に展開してみてください。

[1]: https://zenn.dev/globis/articles/cursor-scratchpad-memories "Cursor と振り返りをして自走力を高める"
[2]: https://forum.cursor.com/t/rules-for-ultra-context-memories-lessons-scratchpad-with-plan-and-act-modes/48792?page=2 "Rules for ultra context, memories, lessons, scratchpad with plan and act modes - Page 2 - Showcase - Cursor - Community Forum"
